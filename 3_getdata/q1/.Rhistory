cube <- function(x,n) {}
cube <- function(x,n) {
x^3
}
cube(3)
x <- 1:10
if (x > 5) { x <- 0 }
f <- function(x) {
g <- function (y){
x + y
}
z <- 4
x + g(x)
}
z <- 10
f(3)
f <- function(x) {
g <- function (y){
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
rd <- rnorm(20)
rd
mean(rd)
rd <- rnorm(200)
mean(rd)
library(datasets)
head(airquality)
airquality
BJsales
cars
crimtab
head(crimtab)
head(crimtab)
head(crimtab)
crimtab
premio <- runif(10,500,1000)
premio
sinistro <- runif(10,450,950)
sinistro
?strptime
search()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function creates a matrix that caches its inverse
makeCacheMatrix <- function(x = matrix()) {
# Saves the inverse in thist variable
i <- NULL
# Set: assign matrix value and set the inverse as NULL
set <- function(y) {
x <<- y
i <<- NULL
}
# Get: returns the matrix value
get <- function() x
# Save the inverse matrix
setinverse <- function(inverse) i <<- inverse
# Get the inverse matrix
getinverse <- function i
#
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function creates a matrix that caches its inverse
makeCacheMatrix <- function(x = matrix()) {
# Saves the inverse in thist variable
i <- NULL
# Set: assign matrix value and set the inverse as NULL
set <- function(y) {
x <<- y
i <<- NULL
}
# Get: returns the matrix value
get <- function() x
# Save the inverse matrix
setinverse <- function(inverse) i <<- inverse
# Get the inverse matrix
getinverse <- function() i
#
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
a <- makeCacheMatrix()
a <- makeCacheMatrix(matrix(c(2,6,4,8), nrow = 2, ncol = 3))
a
a$get
a$get()
a <- makeCacheMatrix(matrix(c(2,6,4,8), nrow = 3, ncol = 3))
a <- makeCacheMatrix(matrix(c(2,6,4,8), nrow = 2, ncol = 2))
a$get()
a$get
a$get()
sove(a$get())
solve(a$get())
cacheSolve <- function(x, ...) {
## Test for inverted matrix and return it if available
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
cacheSolve(a)
cacheSolve(a)
cacheSolve(a)
library(datasets)
data(iris)
?iris
iris
iris$Sepal.Length
iris[]
iris[iris$Species == "virginica"]
iris[iris$Species == "virginica",]
iris$Sepal.Length[iris$Species == "virginica",]
iris[iris$Species == "virginica",]
iris[iris$Species == "virginica",]$Sepal.length
iris[iris$Species == "virginica",]$Sepal.Length
mean(iris[iris$Species == "virginica",]$Sepal.Length)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 1, mean)
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
apply(iris, 2, mean)
apply(iris[, 1:4], 2, mean)
data(mtcars)
?mtcars
describe(mtcars)
info(mtcars)
description(mtcars)
mtcars
sapply(mtcars, cyl, mean)
apply(mtcars, 2, mean)
lapply(mtcars, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
sapply(split(mtcars$mpg, mtcars$hp), mean)
sapply(split(mtcars$hp, mtcars$cyl), mean)
209.21429 - 82.63636
debug(ls)
ls
set.seed(1)
rpoi(5,2)
rpois(5,2)
rnorm(5,1,1)
rnorm(5,3,1)
rnorm(5,3,10)
rnorm(50,3,10)
set.seed(10)
x <-rbinom(10,10,0.5)
x
e <- rnorm(10,0,20)
e
y <- 0.5 + 2* x + e
y
plot(x,y)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
install.packages('rJava')
install.packages('rJava')
.Machine$sizeof.pointer
install.packages('rJava')
q()
library(xml)
install.packages('xml')
install.packages('XML')
install.packages('xml')
library('xml')
library(XML)
fURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(fURL,useInternal=TRUE)
fURL <- "http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(fURL,useInternal=TRUE)
names(doc)
rootNode <- xmlRoot(doc)
names(rootNode)
rootNode[[1]]
xpathSApply(rootNode,"//zipcode",xmlValue)
zips <- xpathSApply(rootNode,"//zipcode",xmlValue)
zips
zips[zips == 21231]
count(zips[zips == 21231])
zips[zips == 21231])
zips[zips == 21231]
zips == 21231
sum(zips == 21231)
fURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv"
download.file(fURL, destfile="idaho.csv", method="curl")
list.files()
setwd("/Users/costa/DataScience/datasciencecoursera/3_getdata")
list.files()
setwd("q1")
list.files()
idaho <- read.table("idaho.csv", sep=",", header=TRUE)
head(idaho)
DT <- fread("idaho", sep=",", header=TRUE)
library(fread)
library("fread")
install.library("fread")
library.install("fread")
install.packages('fread')
DT <- read.table("idaho.csv", sep=",", header=TRUE)
system.time()
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT[DT$SEX==1,]$pwgtp15); mean(DT[DT$SEX==2,]$pwgtp15))
system.time(mean(DT[DT$SEX==1,]$pwgtp15))
system.time(mean(DT[DT$SEX==2,]$pwgtp15))
system.time({rowMeans(DT)[DT$SEX==1]; rowMeans(DT)[DT$SEX==2]})
system.time(rowMeans(DT)[DT$SEX==1])
system.time(mean(DT$pwgtp15,by=DT$SEX))
mean(DT$pwgtp15,by=DT$SEX)
sapply(split(DT$pwgtp15,DT$SEX),mean)
